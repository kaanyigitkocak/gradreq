{"ast":null,"code":"import axios from 'axios';\n\n// Authentication utilities\n\n/**\n * Check if the user is authenticated\n * @returns {boolean} - True if authenticated, false otherwise\n */\nexport const isAuthenticated = () => {\n  const token = localStorage.getItem('token');\n  const expirationDate = localStorage.getItem('tokenExpiration');\n  if (!token || !expirationDate) {\n    return false;\n  }\n\n  // Check if the token is expired\n  const now = new Date();\n  const expiry = new Date(expirationDate);\n  return now < expiry;\n};\n\n/**\n * Log out the user by removing the token from localStorage\n */\nexport const logout = () => {\n  localStorage.removeItem('token');\n  localStorage.removeItem('tokenExpiration');\n  // Remove the Authorization header\n  delete axios.defaults.headers.common['Authorization'];\n};\n\n/**\n * Get the current user's role from the token\n * @returns {string|null} - The user's role or null if not authenticated\n */\nexport const getUserRole = () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) return null;\n    const tokenPayload = JSON.parse(atob(token.split('.')[1]));\n    return tokenPayload[\"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\"];\n  } catch (error) {\n    console.error('Error getting user role:', error);\n    return null;\n  }\n};\n\n/**\n * Set up axios to include the authentication token in all requests\n */\nexport const setupAxiosInterceptors = () => {\n  // If token exists, add it to all requests\n  const token = localStorage.getItem('token');\n  if (token) {\n    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n  }\n\n  // Add a request interceptor to ensure token is included in every request\n  axios.interceptors.request.use(config => {\n    const currentToken = localStorage.getItem('token');\n    if (currentToken && !config.headers.Authorization) {\n      config.headers.Authorization = `Bearer ${currentToken}`;\n    }\n    return config;\n  }, error => Promise.reject(error));\n\n  // Add a response interceptor to handle 401 errors (Unauthorized)\n  axios.interceptors.response.use(response => response, error => {\n    if (error.response && error.response.status === 401) {\n      // Clear auth info and redirect to login\n      logout();\n      window.location.href = '/';\n    }\n    return Promise.reject(error);\n  });\n};\n\n/**\n * Get the user's details (ID, email, etc.) from the token\n * @returns {Object|null} - User details or null if not authenticated\n */\nexport const getUserDetails = () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) return null;\n    const tokenPayload = JSON.parse(atob(token.split('.')[1]));\n    return {\n      id: tokenPayload[\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"],\n      email: tokenPayload[\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"],\n      role: tokenPayload[\"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\"]\n    };\n  } catch (error) {\n    console.error('Error parsing user details:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["axios","isAuthenticated","token","localStorage","getItem","expirationDate","now","Date","expiry","logout","removeItem","defaults","headers","common","getUserRole","tokenPayload","JSON","parse","atob","split","error","console","setupAxiosInterceptors","interceptors","request","use","config","currentToken","Authorization","Promise","reject","response","status","window","location","href","getUserDetails","id","email","role"],"sources":["/Users/yigit/Projects/GradReq/gms-main/src/utils/authUtils.js"],"sourcesContent":["import axios from 'axios';\n\n// Authentication utilities\n\n/**\n * Check if the user is authenticated\n * @returns {boolean} - True if authenticated, false otherwise\n */\nexport const isAuthenticated = () => {\n  const token = localStorage.getItem('token');\n  const expirationDate = localStorage.getItem('tokenExpiration');\n\n  if (!token || !expirationDate) {\n    return false;\n  }\n\n  // Check if the token is expired\n  const now = new Date();\n  const expiry = new Date(expirationDate);\n  return now < expiry;\n};\n\n/**\n * Log out the user by removing the token from localStorage\n */\nexport const logout = () => {\n  localStorage.removeItem('token');\n  localStorage.removeItem('tokenExpiration');\n  // Remove the Authorization header\n  delete axios.defaults.headers.common['Authorization'];\n};\n\n/**\n * Get the current user's role from the token\n * @returns {string|null} - The user's role or null if not authenticated\n */\nexport const getUserRole = () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) return null;\n\n    const tokenPayload = JSON.parse(atob(token.split('.')[1]));\n    return tokenPayload[\"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\"];\n  } catch (error) {\n    console.error('Error getting user role:', error);\n    return null;\n  }\n};\n\n/**\n * Set up axios to include the authentication token in all requests\n */\nexport const setupAxiosInterceptors = () => {\n  // If token exists, add it to all requests\n  const token = localStorage.getItem('token');\n  if (token) {\n    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n  }\n\n  // Add a request interceptor to ensure token is included in every request\n  axios.interceptors.request.use(\n    (config) => {\n      const currentToken = localStorage.getItem('token');\n      if (currentToken && !config.headers.Authorization) {\n        config.headers.Authorization = `Bearer ${currentToken}`;\n      }\n      return config;\n    },\n    (error) => Promise.reject(error)\n  );\n\n  // Add a response interceptor to handle 401 errors (Unauthorized)\n  axios.interceptors.response.use(\n    (response) => response,\n    (error) => {\n      if (error.response && error.response.status === 401) {\n        // Clear auth info and redirect to login\n        logout();\n        window.location.href = '/';\n      }\n      return Promise.reject(error);\n    }\n  );\n};\n\n/**\n * Get the user's details (ID, email, etc.) from the token\n * @returns {Object|null} - User details or null if not authenticated\n */\nexport const getUserDetails = () => {\n  try {\n    const token = localStorage.getItem('token');\n    if (!token) return null;\n\n    const tokenPayload = JSON.parse(atob(token.split('.')[1]));\n    return {\n      id: tokenPayload[\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\"],\n      email: tokenPayload[\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress\"],\n      role: tokenPayload[\"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\"]\n    };\n  } catch (error) {\n    console.error('Error parsing user details:', error);\n    return null;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}